// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String    @id @default(uuid())
  name      String
  email     String    @unique
  password  String
  role      Role      @default(CLIENT)
  provider  Provider? // Back-relation for the owner
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  bookings  Booking[]
  Token     Token[]
  availabilitySlots AvailabilitySlot[]
  referralCode String?
}

model Provider {
  id                String             @id @default(uuid())
  name              String
  ownerId           String             @unique // FK to User.id (owner)
  owner             User               @relation(fields: [ownerId], references: [id])
  services          Service[]
  staff             Staff[]
  availabilitySlots AvailabilitySlot[] // Back-relation for availability slots
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
}

model Service {
  id          String             @id @default(uuid())
  providerId  String
  provider    Provider           @relation(fields: [providerId], references: [id])
  name        String
  durationMin Int // duração do serviço em minutos
  priceCents  Int
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  availSlots  AvailabilitySlot[]
}

model Staff {
  id         String             @id @default(uuid())
  providerId String
  provider   Provider           @relation(fields: [providerId], references: [id])
  name       String
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt
  availSlots AvailabilitySlot[]
}

model AvailabilitySlot {
  id         String     @id @default(uuid())
  providerId String
  provider   Provider   @relation(fields: [providerId], references: [id])
  serviceId  String
  service    Service    @relation(fields: [serviceId], references: [id])
  staffId    String?
  staff      Staff?     @relation(fields: [staffId], references: [id])
  userId     String
  user       User       @relation(fields: [userId], references: [id])
  startAt    DateTime
  endAt      DateTime
  status     SlotStatus @default(OPEN) // OPEN, BOOKED, BLOCKED
  booking    Booking?
  bookingId  String?    @unique
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@unique([providerId, startAt]) // evita slots duplicados para o mesmo instante no mesmo provedor
  @@index([providerId, startAt])
}

model Booking {
  id             String           @id @default(uuid())
  userId         String
  user           User             @relation(fields: [userId], references: [id])
  slotId         String           @unique
  slot           AvailabilitySlot @relation(fields: [slotId], references: [id])
  status         BookingStatus    @default(CONFIRMED) // CONFIRMED, CANCELLED
  cancelToken    String?          @unique // token para cancelamento via e-mail (assíncrono)
  cancelTokenExp DateTime?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
}

enum SlotStatus {
  OPEN
  BOOKED
  BLOCKED
}

enum BookingStatus {
  CONFIRMED
  CANCELLED
}

enum Role {
  PROVIDER
  CLIENT
  ADMIN
}

model Token {
  id        String    @id @default(uuid())
  token     String    @unique
  type      TokenType
  expiresAt DateTime
  revoked   Boolean   @default(false)
  userId    String
  user      User      @relation(fields: [userId], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

enum TokenType {
  REFRESH
  // Add other token types if needed, e.g., PASSWORD_RESET, EMAIL_VERIFICATION
}
